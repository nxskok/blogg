<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:distill="https://distill.pub/journal/" version="2.0">
  <channel>
    <title>Ken's Blog</title>
    <link>http://ritsokiguess.site/blogg/</link>
    <atom:link href="http://ritsokiguess.site/blogg/index.xml" rel="self" type="application/rss+xml"/>
    <description>Ken's Blog
</description>
    <generator>Distill</generator>
    <lastBuildDate>Sun, 07 Nov 2021 00:00:00 +0000</lastBuildDate>
    <item>
      <title>Welcome</title>
      <dc:creator>Ken Butler</dc:creator>
      <link>http://ritsokiguess.site/blogg/posts/2021-11-07-welcome</link>
      <description>The new home of my blog</description>
      <guid>http://ritsokiguess.site/blogg/posts/2021-11-07-welcome</guid>
      <pubDate>Sun, 07 Nov 2021 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>Density plots</title>
      <dc:creator>Ken Butler</dc:creator>
      <link>http://ritsokiguess.site/blogg/posts/2021-11-07-density-plots</link>
      <description>An alternative to histograms and boxplots</description>
      <guid>http://ritsokiguess.site/blogg/posts/2021-11-07-density-plots</guid>
      <pubDate>Sat, 16 Oct 2021 00:00:00 +0000</pubDate>
      <media:content url="http://ritsokiguess.site/blogg/posts/2021-11-07-density-plots/density-plots_files/figure-html5/unnamed-chunk-12-1.png" medium="image" type="image/png" width="1248" height="768"/>
    </item>
    <item>
      <title>Correcting a dataframe</title>
      <dc:creator>Ken Butler</dc:creator>
      <link>http://ritsokiguess.site/blogg/posts/2021-11-07-correcting-a-dataframe</link>
      <description>The tidyverse way.</description>
      <guid>http://ritsokiguess.site/blogg/posts/2021-11-07-correcting-a-dataframe</guid>
      <pubDate>Mon, 26 Apr 2021 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>Sampling locations in a city</title>
      <dc:creator>Ken Butler</dc:creator>
      <link>http://ritsokiguess.site/blogg/posts/2021-11-07-sampling-locations-in-a-city</link>
      <description>with the aim of getting an aerial map of that location.</description>
      <guid>http://ritsokiguess.site/blogg/posts/2021-11-07-sampling-locations-in-a-city</guid>
      <pubDate>Sat, 10 Oct 2020 00:00:00 +0000</pubDate>
      <media:content url="http://ritsokiguess.site/blogg/posts/2021-11-07-sampling-locations-in-a-city/Screenshot_2020-10-10_12-40-39.png" medium="image" type="image/png" width="617" height="431"/>
    </item>
    <item>
      <title>Another tidying problem</title>
      <dc:creator>Ken Butler</dc:creator>
      <link>http://ritsokiguess.site/blogg/posts/2020-07-09-another-tidying-problem</link>
      <description>that ends up with a matched pairs test after tidying.</description>
      <guid>http://ritsokiguess.site/blogg/posts/2020-07-09-another-tidying-problem</guid>
      <pubDate>Thu, 09 Jul 2020 00:00:00 +0000</pubDate>
      <media:content url="http://ritsokiguess.site/blogg/posts/2020-07-09-another-tidying-problem/another-tidying-problem_files/figure-html5/unnamed-chunk-12-1.png" medium="image" type="image/png" width="1248" height="768"/>
    </item>
    <item>
      <title>Understanding the result of a chi-square test</title>
      <dc:creator>Ken Butler</dc:creator>
      <link>http://ritsokiguess.site/blogg/posts/2020-03-14-understanding-the-result-of-a-chi-square-test</link>
      <description>Going beyond the chi-square statistic and its P-value</description>
      <guid>http://ritsokiguess.site/blogg/posts/2020-03-14-understanding-the-result-of-a-chi-square-test</guid>
      <pubDate>Sat, 14 Mar 2020 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>Two header rows and other spreadsheets</title>
      <dc:creator>Ken Butler</dc:creator>
      <link>http://ritsokiguess.site/blogg/posts/2021-11-08-two-header-rows-and-other-spreadsheets</link>
      <description>Tidying data arranged in odd ways</description>
      <guid>http://ritsokiguess.site/blogg/posts/2021-11-08-two-header-rows-and-other-spreadsheets</guid>
      <pubDate>Sun, 01 Dec 2019 00:00:00 +0000</pubDate>
      <media:content url="http://ritsokiguess.site/blogg/posts/2021-11-08-two-header-rows-and-other-spreadsheets/two-header-rows-and-other-spreadsheets_files/figure-html5/unnamed-chunk-9-1.png" medium="image" type="image/png" width="1248" height="768"/>
    </item>
    <item>
      <title>Un-counting</title>
      <dc:creator>Ken Butler</dc:creator>
      <link>http://ritsokiguess.site/blogg/posts/2019-07-13-un-counting</link>
      <description>Why you would want to do the opposite of counting</description>
      <guid>http://ritsokiguess.site/blogg/posts/2019-07-13-un-counting</guid>
      <pubDate>Sat, 13 Jul 2019 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>Some things I learned today</title>
      <dc:creator>Ken Butler</dc:creator>
      <link>http://ritsokiguess.site/blogg/posts/2021-11-12-some-things-i-learned-today</link>
      <description>Stan files; R Markdown figures in LaTeX; Beamer in R Markdown; Build All and makefiles</description>
      <guid>http://ritsokiguess.site/blogg/posts/2021-11-12-some-things-i-learned-today</guid>
      <pubDate>Wed, 22 May 2019 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>Changing a lot of things in a lot of places</title>
      <dc:creator>Ken Butler</dc:creator>
      <link>http://ritsokiguess.site/blogg/posts/2021-11-19-changing-a-lot-of-things-in-a-lot-of-places</link>
      <description>


&lt;h2 id="packages"&gt;Packages&lt;/h2&gt;
&lt;pre class="r"&gt;&lt;code&gt;library(tidyverse)&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Let’s suppose you have a data frame like this:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;d&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 5 × 3
  x1       x2    y     
  &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt; 
1 one      two   two   
2 four     three four  
3 seven    nine  eight 
4 six      eight seven 
5 fourteen nine  twelve&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What you want to do is to change all the even numbers in columns &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, but &lt;em&gt;not&lt;/em&gt; &lt;code&gt;y&lt;/code&gt;, to the number versions of themselves, so that, for example, &lt;code&gt;eight&lt;/code&gt; becomes &lt;code&gt;8&lt;/code&gt;. This would seem to be a job for &lt;code&gt;str_replace_all&lt;/code&gt;, but how to manage the multitude of changes?&lt;/p&gt;
&lt;h2 id="making-a-lot-of-changes-with-str_replace_all"&gt;Making a lot of changes with &lt;code&gt;str_replace_all&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;I learned today that you can feed &lt;code&gt;str_replace_all&lt;/code&gt; a &lt;em&gt;named vector&lt;/em&gt;. Wossat, you say? Well, one of these:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;quantile(1:7)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;  0%  25%  50%  75% 100% 
 1.0  2.5  4.0  5.5  7.0 &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The numbers are here the five-number summary; the things next to them, that say which percentile they are, are the &lt;code&gt;names&lt;/code&gt; attribute. You can make one of these yourself like this:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;x &amp;lt;- 1:3
x&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] 1 2 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;names(x) &amp;lt;- c(&amp;quot;first&amp;quot;, &amp;quot;second&amp;quot;, &amp;quot;third&amp;quot;)
x&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt; first second  third 
     1      2      3 &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The value of this for us is that you can feed the boatload of potential changes into &lt;code&gt;str_replace_all&lt;/code&gt; by feeding it a named vector of the changes it might make.&lt;/p&gt;
&lt;p&gt;In our example, we wanted to replace the even numbers by the numeric versions of themselves, so let’s make a little data frame with all of those:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;changes &amp;lt;- tribble(
  ~from, ~to,
  &amp;quot;two&amp;quot;, &amp;quot;2&amp;quot;,
  &amp;quot;four&amp;quot;, &amp;quot;4&amp;quot;,
  &amp;quot;six&amp;quot;, &amp;quot;6&amp;quot;,
  &amp;quot;eight&amp;quot;, &amp;quot;8&amp;quot;,
  &amp;quot;ten&amp;quot;, &amp;quot;10&amp;quot;,
  &amp;quot;twelve&amp;quot;, &amp;quot;12&amp;quot;,
  &amp;quot;fourteen&amp;quot;, &amp;quot;14&amp;quot;
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I think this is as high as we need to go. I like a &lt;code&gt;tribble&lt;/code&gt; for this so that you can easily see what is going to replace what.&lt;/p&gt;
&lt;p&gt;For the named vector, the &lt;em&gt;values&lt;/em&gt; are the new values (the ones I called &lt;code&gt;to&lt;/code&gt; in &lt;code&gt;changes&lt;/code&gt;), while the &lt;em&gt;names&lt;/em&gt; are the old ones (&lt;code&gt;from&lt;/code&gt;). So let’s construct that. There is one extra thing: I want to replace whole words only (and not end up with something like &lt;code&gt;4teen&lt;/code&gt;, which sounds like one of those 90s boy bands), so what I’ll do is to put “word boundaries”&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; around the &lt;code&gt;from&lt;/code&gt; values:&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;my_changes &amp;lt;- changes$to
names(my_changes) &amp;lt;- str_c(&amp;quot;\\b&amp;quot;, changes$from, &amp;quot;\\b&amp;quot;)
my_changes&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;     \\btwo\\b     \\bfour\\b      \\bsix\\b    \\beight\\b 
           &amp;quot;2&amp;quot;            &amp;quot;4&amp;quot;            &amp;quot;6&amp;quot;            &amp;quot;8&amp;quot; 
     \\bten\\b   \\btwelve\\b \\bfourteen\\b 
          &amp;quot;10&amp;quot;           &amp;quot;12&amp;quot;           &amp;quot;14&amp;quot; &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and that seems to reflect the changes we want to make. So let’s make it go, just on columns &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;:&lt;a href="#fn3" class="footnote-ref" id="fnref3"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;d %&amp;gt;% mutate_at(
  vars(starts_with(&amp;quot;x&amp;quot;)),
       ~ str_replace_all(., my_changes)
  )&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 5 × 3
  x1    x2    y     
  &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt; 
1 one   2     two   
2 4     three four  
3 seven nine  eight 
4 6     8     seven 
5 14    nine  twelve&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;“for each of the columns that starts with &lt;code&gt;x&lt;/code&gt;, replace everything in it that’s in the recipe in &lt;code&gt;my_changes&lt;/code&gt;.”&lt;/p&gt;
&lt;p&gt;It seems to have worked, and not a 90s boy band in sight.&lt;/p&gt;
&lt;pre class="r distill-force-highlighting-css"&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;div class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;&lt;a href="https://stackoverflow.com/questions/24085680/why-do-backslashes-appear-twice"&gt;This Stack Overflow answer&lt;/a&gt; explains why the backslashes need to be doubled. The answer is for Python, but the same issue applies to R.&lt;a href="#fnref1" class="footnote-back"&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;This means that the number names only match if they are surrounded by non-word characters, that is, spaces, or the beginning or end of the text.&lt;a href="#fnref2" class="footnote-back"&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3"&gt;&lt;p&gt;The modern way to do this is to use &lt;code&gt;across&lt;/code&gt;, but I wrote this post in 2019, and this is all we had then.&lt;a href="#fnref3" class="footnote-back"&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
      <distill:md5>78be5794cc5a96025ce89f642f989a88</distill:md5>
      <guid>http://ritsokiguess.site/blogg/posts/2021-11-19-changing-a-lot-of-things-in-a-lot-of-places</guid>
      <pubDate>Sun, 12 May 2019 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>Distance between clusters</title>
      <dc:creator>Ken Butler</dc:creator>
      <link>http://ritsokiguess.site/blogg/posts/2021-11-19-distance-between-clusters</link>
      <description>


&lt;h2 id="packages"&gt;Packages&lt;/h2&gt;
&lt;pre class="r"&gt;&lt;code&gt;library(tidyverse)
library(spatstat.geom)&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Hierarchical cluster analysis is based on distances between individuals. This can be defined via Euclidean distance, Manhattan distance, a matching coefficient, etc. I won’t get into these further.&lt;/p&gt;
&lt;p&gt;There is a second problem, though, which I do wish to discuss: when you carry out a hierarchical cluster analysis, you want to join the two closest &lt;em&gt;clusters&lt;/em&gt; together at each step. But how do you work out how far apart two clusters are, when all you have are distances between individuals? Here, I give some examples, and, perhaps more interesting, some visuals with the code that makes them.&lt;/p&gt;
&lt;h2 id="inter-cluster-distances"&gt;Inter-cluster distances&lt;/h2&gt;
&lt;h3 id="some-clusters-to-find-differences-between"&gt;Some clusters to find differences between&lt;/h3&gt;
&lt;p&gt;Let’s make some random points in two dimensions that are in two clusters: 5 points each, uniformly distributed on &lt;span class="math inline"&gt;\((0,20)^2\)&lt;/span&gt; and &lt;span class="math inline"&gt;\((20,40)^2\)&lt;/span&gt;:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;set.seed(457299)
A=tibble(x=runif(5,0,20),y=runif(5,0,20))
B=tibble(x=runif(5,20,40),y=runif(5,20,40))
ddd=bind_rows(A=A,B=B,.id=&amp;quot;cluster&amp;quot;)
g=ggplot(ddd,aes(x=x,y=y,colour=cluster))+geom_point()+
  coord_fixed(xlim=c(0,40),ylim=c(0,40))
g&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="filed8d22e131ab4_files/figure-html/unnamed-chunk-2-1.png" width="672" /&gt;&lt;/p&gt;
&lt;p&gt;Note that I gave this graph a name, so that I can add things to it later.&lt;/p&gt;
&lt;p&gt;We know how to measure distances between &lt;em&gt;individuals&lt;/em&gt;, but what about distances between &lt;em&gt;clusters&lt;/em&gt;?&lt;/p&gt;
&lt;h3 id="single-linkage"&gt;Single linkage&lt;/h3&gt;
&lt;p&gt;One way to measure the distance between two clusters is to pick a point from each cluster to represent that cluster, and use the distance between those. For example, we might find the points in cluster A and and in cluster B that are closest together, and say that the distance between the two clusters is the distance between those two points.&lt;/p&gt;
&lt;p&gt;So, we need all the distances between a point in A and a point in B. The package &lt;code&gt;spatstat.geom&lt;/code&gt; has a function &lt;code&gt;crossdist&lt;/code&gt; that does exactly this:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;dist=distances=spatstat.geom::crossdist(A$x, A$y, B$x, B$y)
dist&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;         [,1]     [,2]     [,3]     [,4]     [,5]
[1,] 25.15504 17.21720 12.36243 24.28935 23.34414
[2,] 43.98827 35.44714 29.91026 41.73130 42.46700
[3,] 42.82409 34.39974 28.93598 40.86692 41.19940
[4,] 32.97612 24.52382 19.07809 31.05325 31.42569
[5,] 32.54432 23.73306 18.08921 29.39528 31.48468&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a &lt;code&gt;matrix&lt;/code&gt;. From this, we want to find out which points are the two that have the smallest distance between them. It looks like point 1 in A and point 3 in B (the middle distance of the top row). We can use base R to verify this:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;wm1=which.min(apply(distances,1,min))
wm1&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;wm2=which.min(apply(distances,2,min))
wm2&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;closest=bind_rows(A=A[wm1,],B=B[wm2,],.id=&amp;quot;cluster&amp;quot;)
closest&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 2 × 3
  cluster     x     y
  &amp;lt;chr&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
1 A        19.0  15.0
2 B        22.8  26.8&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So we can join the two closest points, now that we know where they are:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;g+geom_segment(data=closest,aes(x=x[1],y=y[1],xend=x[2],yend=y[2]),colour=&amp;quot;darkgreen&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="filed8d22e131ab4_files/figure-html/unnamed-chunk-5-1.png" width="672" /&gt;&lt;/p&gt;
&lt;p&gt;This works, but it isn’t very elegant (or very &lt;code&gt;tidyverse&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;I usually use &lt;code&gt;crossing&lt;/code&gt; for this kind of thing, but the points in &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; have both an &lt;code&gt;x&lt;/code&gt; and a &lt;code&gt;y&lt;/code&gt; coordinate. I use a hack: &lt;code&gt;unite&lt;/code&gt; to combine them together into one thing, then &lt;code&gt;separate&lt;/code&gt; after making all possible pairs:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;A %&amp;gt;% unite(coord, x, y) -&amp;gt; a1
B %&amp;gt;% unite(coord, x, y) -&amp;gt; b1
crossing(A_coord=a1$coord, B_coord=b1$coord) %&amp;gt;% 
  separate(A_coord, into=c(&amp;quot;A_x&amp;quot;, &amp;quot;A_y&amp;quot;), sep=&amp;quot;_&amp;quot;, convert=T) %&amp;gt;% 
  separate(B_coord, into=c(&amp;quot;B_x&amp;quot;, &amp;quot;B_y&amp;quot;), sep=&amp;quot;_&amp;quot;, convert=T) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 25 × 4
     A_x   A_y   B_x   B_y
   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
 1  11.2  11.7  22.8  26.8
 2  11.2  11.7  27.4  30.0
 3  11.2  11.7  28.8  37.3
 4  11.2  11.7  35.2  34.2
 5  11.2  11.7  35.7  31.3
 6  19.0  15.0  22.8  26.8
 7  19.0  15.0  27.4  30.0
 8  19.0  15.0  28.8  37.3
 9  19.0  15.0  35.2  34.2
10  19.0  15.0  35.7  31.3
# … with 15 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The reason for the &lt;code&gt;sep&lt;/code&gt; in the &lt;code&gt;separate&lt;/code&gt; is that &lt;code&gt;separate&lt;/code&gt; also counts the decimal points as separators, which I want to exclude; the only separators should be the underscores that &lt;code&gt;unite&lt;/code&gt; introduced. The &lt;code&gt;convert&lt;/code&gt; turns the coordinates back into numbers.&lt;/p&gt;
&lt;p&gt;Now I find the (Euclidean) distances and then the smallest one:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;crossing(A_coord=a1$coord, B_coord=b1$coord) %&amp;gt;% 
  separate(A_coord, into=c(&amp;quot;A_x&amp;quot;, &amp;quot;A_y&amp;quot;), sep=&amp;quot;_&amp;quot;, convert=T) %&amp;gt;% 
  separate(B_coord, into=c(&amp;quot;B_x&amp;quot;, &amp;quot;B_y&amp;quot;), sep=&amp;quot;_&amp;quot;, convert=T) %&amp;gt;% 
  mutate(dist=sqrt((A_x-B_x)^2+(A_y-B_y)^2)) -&amp;gt; distances
distances %&amp;gt;% arrange(dist) %&amp;gt;% slice(1) -&amp;gt; d
d&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 1 × 5
    A_x   A_y   B_x   B_y  dist
  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
1  19.0  15.0  22.8  26.8  12.4&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and then I add it to my plot:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;g+geom_segment(data=d, aes(x=A_x, y=A_y, xend=B_x, yend=B_y), colour=&amp;quot;darkgreen&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="filed8d22e131ab4_files/figure-html/unnamed-chunk-8-1.png" width="672" /&gt;&lt;/p&gt;
&lt;p&gt;A problem with single linkage is that two clusters are close if a point in A and a point in B happen to be close. The other red and blue points on the graph could be &lt;em&gt;anywhere&lt;/em&gt;. You could say that this goes against two clusters being “close”. The impact in cluster analysis is that you get “stringy” clusters where single points are added on to clusters one at a time. Can we improve on that?&lt;/p&gt;
&lt;h3 id="complete-linkage"&gt;Complete linkage&lt;/h3&gt;
&lt;p&gt;Another way to measure the distance between two clusters is the &lt;em&gt;longest&lt;/em&gt; distance between a point in A and a point in B. This will make two clusters close if &lt;em&gt;everything&lt;/em&gt; in the two clusters is close. You could reasonably argue that this is a better idea than single linkage.&lt;/p&gt;
&lt;p&gt;After the work we did above, this is simple to draw: take the data frame &lt;code&gt;distances&lt;/code&gt;, find the &lt;em&gt;largest&lt;/em&gt; distance, and add it to the plot:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;distances %&amp;gt;% arrange(desc(dist)) %&amp;gt;% slice(1) -&amp;gt; d
g+geom_segment(data=d, aes(x=A_x, y=A_y, xend=B_x, yend=B_y), colour=&amp;quot;darkgreen&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="filed8d22e131ab4_files/figure-html/unnamed-chunk-9-1.png" width="672" /&gt;&lt;/p&gt;
&lt;h3 id="wards-method"&gt;Ward’s method&lt;/h3&gt;
&lt;p&gt;Let’s cast our minds back to analysis of variance, which gives another way of thinking about distance between groups (in one dimension). Consider these data:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;d1=tribble(
  ~y, ~g,
  10, &amp;quot;A&amp;quot;,
  11, &amp;quot;A&amp;quot;,
  13, &amp;quot;A&amp;quot;,
  11, &amp;quot;B&amp;quot;,
  12, &amp;quot;B&amp;quot;,
  14, &amp;quot;B&amp;quot;
)
d1&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 6 × 2
      y g    
  &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;
1    10 A    
2    11 A    
3    13 A    
4    11 B    
5    12 B    
6    14 B    &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The two groups here are pretty close together, relative to how spread out they are:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;ggplot(d1, aes(x=g, y=y, colour=g))+geom_point()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="filed8d22e131ab4_files/figure-html/unnamed-chunk-11-1.png" width="672" /&gt;&lt;/p&gt;
&lt;p&gt;and the analysis of variance concurs:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;d1.1=aov(y~g, data=d1)
summary(d1.1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;            Df Sum Sq Mean Sq F value Pr(&amp;gt;F)
g            1  1.500   1.500   0.643  0.468
Residuals    4  9.333   2.333               &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;span class="math inline"&gt;\(F\)&lt;/span&gt;-value is small because the variability between groups is small compared to the variability within groups; it’s reasonable to act as if the two groups have the same mean.&lt;/p&gt;
&lt;p&gt;Compare that with this data set:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;d2=tribble(
  ~y, ~g,
  10, &amp;quot;A&amp;quot;,
  11, &amp;quot;A&amp;quot;,
  13, &amp;quot;A&amp;quot;,
  21, &amp;quot;B&amp;quot;,
  22, &amp;quot;B&amp;quot;,
  24, &amp;quot;B&amp;quot;
)
d2&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 6 × 2
      y g    
  &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;
1    10 A    
2    11 A    
3    13 A    
4    21 B    
5    22 B    
6    24 B    &lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;ggplot(d2, aes(x=g, y=y, colour=g))+geom_point()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="filed8d22e131ab4_files/figure-html/unnamed-chunk-14-1.png" width="672" /&gt;&lt;/p&gt;
&lt;p&gt;How do within-groups and between-groups compare this time?&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;d2.1=aov(y~g, data=d2)
summary(d2.1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;            Df Sum Sq Mean Sq F value   Pr(&amp;gt;F)    
g            1 181.50  181.50   77.79 0.000912 ***
Residuals    4   9.33    2.33                     
---
Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This time the variability between groups is &lt;em&gt;much&lt;/em&gt; larger than the variability within groups; we have (strong) evidence that the group means are different, and it makes sense to treat the groups separately.&lt;/p&gt;
&lt;p&gt;How does that apply to cluster distances? Well, what is happening here is comparing squared distances from group means to distances from the overall mean. Let’s see:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;d1 %&amp;gt;% summarize(m=mean(y)) -&amp;gt; d1.overall
d1.overall&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 1 × 1
      m
  &amp;lt;dbl&amp;gt;
1  11.8&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;d1 %&amp;gt;% mutate(mean=d1.overall$m) %&amp;gt;% 
  mutate(diffsq=(y-mean)^2) %&amp;gt;% 
  summarize(total=sum(diffsq))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 1 × 1
  total
  &amp;lt;dbl&amp;gt;
1  10.8&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is the sum of squared differences from the mean of all the observations taken together. What about the same thing, but from each group mean?&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;d1 %&amp;gt;% group_by(g) %&amp;gt;% summarize(m=mean(y)) -&amp;gt; d1.groups
d1.groups&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 2 × 2
  g         m
  &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt;
1 A      11.3
2 B      12.3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;d1 %&amp;gt;% left_join(d1.groups) %&amp;gt;% 
  mutate(diffsq=(y-m)^2) %&amp;gt;% 
  summarize(total=sum(diffsq))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 1 × 1
  total
  &amp;lt;dbl&amp;gt;
1  9.33&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One way to measure the distance between two groups (clusters) is to take the difference of these. The observations will always be closer to their own group mean than to the combined mean, but in this case the difference is small:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;10.8-9.33&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] 1.47&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Thinking of these as clusters, these are close together and could easily be combined.&lt;/p&gt;
&lt;p&gt;What about the two groups that look more distinct?&lt;/p&gt;
&lt;p&gt;The distance from the overall mean is:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;d2 %&amp;gt;% summarize(m=mean(y)) -&amp;gt; d2.overall
d2.overall&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 1 × 1
      m
  &amp;lt;dbl&amp;gt;
1  16.8&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;d2 %&amp;gt;% mutate(mean=d2.overall$m) %&amp;gt;% 
  mutate(diffsq=(y-mean)^2) %&amp;gt;% 
  summarize(total=sum(diffsq))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 1 × 1
  total
  &amp;lt;dbl&amp;gt;
1  191.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and from the separate group means is&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;d2 %&amp;gt;% group_by(g) %&amp;gt;% summarize(m=mean(y)) -&amp;gt; d2.groups
d2.groups&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 2 × 2
  g         m
  &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt;
1 A      11.3
2 B      22.3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;d2 %&amp;gt;% left_join(d2.groups) %&amp;gt;% 
  mutate(diffsq=(y-m)^2) %&amp;gt;% 
  summarize(total=sum(diffsq))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 1 × 1
  total
  &amp;lt;dbl&amp;gt;
1  9.33&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This time the difference is&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;191-9.33&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] 181.67&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is much bigger, and combining these groups would not be a good idea.&lt;/p&gt;
&lt;p&gt;For cluster analysis, these ideas are behind Ward’s method. Compare the distances of each point from the mean of the clusters they currently belong to, with the distances from the mean of those two clusters combined. If the difference between these is small, the two clusters could be combined; if not, the two clusters should not be combined if possible.&lt;/p&gt;
&lt;p&gt;How does this look on a picture? I did this in my lecture notes with some hairy for-loops, but I think I can do better.&lt;/p&gt;
&lt;p&gt;Let’s first work out the means for each of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; for my clusters:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;ddd %&amp;gt;% group_by(cluster) %&amp;gt;% 
  summarize(mean_x=mean(x), mean_y=mean(y)) -&amp;gt; means
means&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 2 × 3
  cluster mean_x mean_y
  &amp;lt;chr&amp;gt;    &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
1 A         9.01   10.5
2 B        30.0    31.9&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now I look up which cluster each observation was in and add its mean. (I surreptitiously used this idea above):&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;ddd %&amp;gt;% left_join(means) -&amp;gt; group_means
group_means&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 10 × 5
   cluster     x     y mean_x mean_y
   &amp;lt;chr&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
 1 A       19.0  15.0    9.01   10.5
 2 A        2.49  4.84   9.01   10.5
 3 A        4.55  4.34   9.01   10.5
 4 A       11.2  11.7    9.01   10.5
 5 A        7.88 16.6    9.01   10.5
 6 B       35.2  34.2   30.0    31.9
 7 B       27.4  30.0   30.0    31.9
 8 B       22.8  26.8   30.0    31.9
 9 B       28.8  37.3   30.0    31.9
10 B       35.7  31.3   30.0    31.9&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and then I think I can add the lines, coloured by cluster, thus:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;g+geom_segment(data=group_means, aes(x=x, y=y, xend=mean_x, yend=mean_y, colour=cluster))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="filed8d22e131ab4_files/figure-html/unnamed-chunk-24-1.png" width="672" /&gt;&lt;/p&gt;
&lt;p&gt;The points are reasonably close to their group means.&lt;/p&gt;
&lt;p&gt;How does that compare to the distances from the overall mean? First we have to work that out:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;ddd %&amp;gt;% summarize(mean_x=mean(x), mean_y=mean(y)) -&amp;gt; means&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then we glue this onto to the original points:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;ddd %&amp;gt;% mutate(mean_x=means$mean_x, mean_y=means$mean_y) -&amp;gt; overall_means
overall_means&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 10 × 5
   cluster     x     y mean_x mean_y
   &amp;lt;chr&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
 1 A       19.0  15.0    19.5   21.2
 2 A        2.49  4.84   19.5   21.2
 3 A        4.55  4.34   19.5   21.2
 4 A       11.2  11.7    19.5   21.2
 5 A        7.88 16.6    19.5   21.2
 6 B       35.2  34.2    19.5   21.2
 7 B       27.4  30.0    19.5   21.2
 8 B       22.8  26.8    19.5   21.2
 9 B       28.8  37.3    19.5   21.2
10 B       35.7  31.3    19.5   21.2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and then repeat the previous idea to plot them:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;g+geom_segment(data=overall_means, aes(x=x, y=y, xend=mean_x, yend=mean_y), colour=&amp;quot;darkgreen&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="filed8d22e131ab4_files/figure-html/unnamed-chunk-27-1.png" width="672" /&gt;&lt;/p&gt;
&lt;p&gt;The points are a lot further from the overall mean than from the group means (the green lines overall are longer than the red and blue ones), suggesting that the clusters are, in the sense of Ward’s method, a long way apart.&lt;/p&gt;
&lt;pre class="r distill-force-highlighting-css"&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;</description>
      <distill:md5>81c7922ca2fe0d34a0e06016bda7870d</distill:md5>
      <guid>http://ritsokiguess.site/blogg/posts/2021-11-19-distance-between-clusters</guid>
      <pubDate>Tue, 23 Apr 2019 00:00:00 +0000</pubDate>
      <media:content url="http://ritsokiguess.site/blogg/posts/2021-11-19-distance-between-clusters/distance-between-clusters_files/figure-html5/unnamed-chunk-2-1.png" medium="image" type="image/png" width="1248" height="768"/>
    </item>
  </channel>
</rss>
